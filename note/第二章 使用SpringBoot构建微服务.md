# 第二章 使用Spring Boot构建微服务

## 1 架构师的故事：设计微服务架构
### 1.1 分解业务问题
把一个复杂性的问题，分解为几个模块。这样降低了复杂性，并且方便管理。分解业务时有如下指导方针：
1. *注意描述需求的名词*。反复出现的名词通常是业务的核心域，并且适合创建微服务。
2. *注意描述需求的动词*。描述中的动词是需求的自然轮廓，例如：查找、更新。
3. *寻找数据内聚*。微服务应该拥有完全数据自己的数据，如果涉及到完全不相关的数据，应该还有遗漏的微服务。
### 1.2 建立服务粒度
粒度建立思想：
1. 开始的时候可以粒度粗一些（微服务涉及的范围广），后面重构到细粒度的微服务。
2. 重点关注服务之间如何交互。
3. 微服务是否能支持业务范围的增长。
### 1.3 互相交流：定义接口服务
接口设计思想：
1. 拥抱REST理念。（围绕GET、POST、PUT、DELETE建模）
2. 使用URI来传达意图。
3. 请求和响应使用JSON。（轻量、易用）
4. 使用HTTP状态码来传达结果。

## 2 何时不应该使用微服务
1. 有时业务十分简单，单体应用程序更加简单合适，没必要引入微服务架构。 微服务架构相比单体应用程序更加复杂，需要投入更多的运维成本，权衡一下值不值得。
2. 微服务因为他的分布式特性导致他在做事务性任务时需要更大的代价。

## 3 开发人员的故事：用Spring Boot和Java构建微服务
### 3.1 采坑
1. 跑不起来，出现下面的报错：
```
licensingservice_1  | /bin/sh: ./run.sh: not found
common_licensingservice_1 exited with code 127
```
mac上没有这个问题，windows就会报错。把`CMD ./run.sh`改成了`CMD sh run.sh`就可以了。
2. docker执行run.sh之后，报错：Unable to access jarfile /usr/local/licensingservice/licensing-service-0.0.1-SNAPSHOT.jar

### 3.2 总结
 一个Spring Boot微服务基于一个引导类与一个控制器类。
 1. 引导类负责启动与初始化应用程序。使用SpringBootApplication注解。
 2. 控制器类负责公开服务的HTTP端点。 使用RestController注解。 另外RequestMapping注解来声明对外端口。

## 4 DevOps工程师的故事：构建运行时的严谨性
### 4.1 运维生命周期步骤
1. 服务装配：只要是相同服务，那么他们的代码与运行时环境就要一致，把运行时环境和程序本身打包到一起就可以了。（打包与部署微服务）
2. 服务引导：从中央位置读取服务自身需要的配置数据。
3. 服务发现：部署一个新的服务实例时，让这个服务可以被客户端发现。（用代理来实现）
4. 服务监控：监控微服务实例，获取微服务运行状态。确保避免故障。
### 4.2 运维采坑
1. docker的image的名字不可以带大写字母
2. pom.xml注意pluginManagment的意义